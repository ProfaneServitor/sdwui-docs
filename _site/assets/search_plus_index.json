{"/jekyll-gitbook/pages/contact/": {
    "title": "Contact",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/contact/",
    "body": "This is an contact page."
  },"/jekyll-gitbook/pages/design/draft/": {
    "title": "Design Draft",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/design/draft/",
    "body": "This is an draft page."
  },"/jekyll-gitbook/api/": {
    "title": "API guide",
    "keywords": "",
    "url": "/jekyll-gitbook/api/",
    "body": "First, of course, is to run web ui with --api commandline argument example in your “webui-user.bat”: set COMMANDLINE_ARGS=--api This enables the api which can be reviewed at http://127.0.0.1:7860/docs (or whever the URL is + /docs) The basic ones I’m interested in are these two. Let’s just focus only on ` /sdapi/v1/txt2img` When you expand that tab, it gives an example of a payload to send to the API. I used this often as reference. So that’s the backend. The API basically says what’s available, what it’s asking for, and where to send it. Now moving onto the frontend, I’ll start with constructing a payload with the parameters I want. An example can be: payload = { \"prompt\": \"maltese puppy\", \"steps\": 5 } I can put in as few or as many parameters as I want in the payload. The API will use the defaults for anything I don’t set. After that, I can send it to the API response = requests.post(url=f'http://127.0.0.1:7860/sdapi/v1/txt2img', json=payload) Again, this URL needs to match the web ui’s URL. If we execute this code, the web ui will generate an image based on the payload. That’s great, but then what? There is no image anywhere… After the backend does its thing, the API sends the response back in a variable that was assigned above: response. The response contains three entries; “images”, “parameters”, and “info”, and I have to find some way to get the information from these entries. First, I put this line r = response.json() to make it easier to work with the response. “images” is the generated image, which is what I want mostly. There’s no link or anything; it’s a giant string of random characters, apparently we have to decode it. This is how I do it: for i in r['images']: image = Image.open(io.BytesIO(base64.b64decode(i.split(\",\",1)[0]))) With that, we have an image in the image variable that we can work with, for example saving it with image.save('output.png'). “parameters” shows what was sent to the API, which could be useful, but what I want in this case is “info”. I use it to insert metadata into the image, so I can drop it into web ui PNG Info. For that, I can access the /sdapi/v1/png-info API. I’ll need to feed the image I got above into it. png_payload = { \"image\": \"data:image/png;base64,\" + i } response2 = requests.post(url=f'http://127.0.0.1:7860/sdapi/v1/png-info', json=png_payload) After that, I can get the information with response2.json().get(\"info\") A sample code that should work can look like this: import json import requests import io import base64 from PIL import Image, PngImagePlugin url = \"http://127.0.0.1:7860\" payload = { \"prompt\": \"puppy dog\", \"steps\": 5 } response = requests.post(url=f'{url}/sdapi/v1/txt2img', json=payload) r = response.json() for i in r['images']: image = Image.open(io.BytesIO(base64.b64decode(i.split(\",\",1)[0]))) png_payload = { \"image\": \"data:image/png;base64,\" + i } response2 = requests.post(url=f'{url}/sdapi/v1/png-info', json=png_payload) pnginfo = PngImagePlugin.PngInfo() pnginfo.add_text(\"parameters\", response2.json().get(\"info\")) image.save('output.png', pnginfo=pnginfo) Import the things I need define the url and the payload to send send said payload to said url through the API in a loop grab “images” and decode it for each image, send it to png info API and get that info back define a plugin to add png info, then add the png info I defined into it at the end here, save the image with the png info A note on \"override_settings\". The purpose of this endpoint is to override the web ui settings for a single request, such as the CLIP skip. The settings that can be passed into this parameter are visible here at the url’s /docs. You can expand the tab and the API will provide a list. There are a few ways you can add this value to your payload, but this is how I do it. I’ll demonstrate with “filter_nsfw”, and “CLIP_stop_at_last_layers”. payload = { \"prompt\": \"cirno\", \"steps\": 20 } override_settings = {} override_settings[\"filter_nsfw\"] = true override_settings[\"CLIP_stop_at_last_layers\"] = 2 override_payload = { \"override_settings\": override_settings } payload.update(override_payload) Have the normal payload after that, initialize a dictionary (I call it “override_settings”, but maybe not the best name) then I can add as many key:value pairs as I want to it make a new payload with just this parameter update the original payload to add this one to it So in this case, when I send the payload, I should get a “cirno” at 20 steps, with the CLIP skip at 2, as well as the NSFW filter on. For certain settings or situations, you may want your changes to stay. For that you can post to the /sdapi/v1/options API endpoint We can use what we learned so far and set up the code easily for this. Here is an example: url = \"http://127.0.0.1:7860\" option_payload = { \"sd_model_checkpoint\": \"Anything-V3.0-pruned.ckpt [2700c435]\", \"CLIP_stop_at_last_layers\": 2 } response = requests.post(url=f'{url}/sdapi/v1/options', json=option_payload) After sending this payload to the API, the model should swap to the one I set and set the CLIP skip to 2. Reiterating, this is different from “override_settings”, because this change will persist, while “override_settings” is for a single request. Note that if you’re changing the sd_model_checkpoint, the value should be the name of the checkpoint as it appears in the web ui. This can be referenced with this API endpoint (same way we reference “options” API) The “title” (name and hash) is what you want to use. This is as of commit 47a44c7 For a more complete implementation of a frontend, my Discord bot is here if anyone wants to look at it as an example. Most of the action happens in stablecog.py. There are many comments explaining what each code does. This guide can be found in discussions page. Also, check out this python API client library for webui: https://github.com/mix1009/sdwebuiapi"
  },"/jekyll-gitbook/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/about/",
    "body": "This is an about page."
  },"/jekyll-gitbook/jekyll/2022-06-30-tips_warnings_dangers.html": {
    "title": "Tips, Warnings, and Dangers",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-06-30-tips_warnings_dangers.html",
    "body": "The jekyll-theme supports tips, warnings, and dangers blocks and the style is referred from the discord.js website. You could have the following markdown attributes (supported by kramdown): Tips Using a {: .block-tip} attribute: &gt; ##### TIP &gt; &gt; This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have &gt; this or a similar version after installation. {: .block-tip } TIP This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have this or a similar version after installation. Warnings Using a {: .block-warning} attribute: &gt; ##### WARNING &gt; &gt; Be sure that you're familiar with things like async/await and object destructuring &gt; before continuing, as we'll be making use of features like these. {: .block-warning } WARNING Be sure that you’re familiar with things like async/await and object destructuring before continuing, as we’ll be making use of features like these. Dangers Using a {: .block-danger} attribute: &gt; ##### DANGER &gt; &gt; You cannot delete an ephemeral message. {: .block-danger } DANGER You cannot delete an ephemeral message."
  },"/jekyll-gitbook/jekyll/2022-06-26-wide_tables.html": {
    "title": "Wide tables",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-06-26-wide_tables.html",
    "body": "A wide tables needs to be wrapped into a div with class table-wrapper to make sure it displayed as expected on mobile devices. For example, &lt;div class=\"table-wrapper\" markdown=\"block\"&gt; |title1|title2|title3|title4|title5|title6|title7|title8| |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| |1|2|3|4|5|6|7|8| &lt;/div&gt; Will be rendered as title1 title2 title3 title4 title5 title6 title7 title8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8"
  },"/jekyll-gitbook/jekyll/2022-05-24-page_cover.html": {
    "title": "Page with cover image",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-05-24-page_cover.html",
    "body": "The jekyll-gitbook theme supports adding a cover image to a specific page by adding a cover field to the page metadata: --- title: Page with cover image author: Tao He date: 2022-05-24 category: Jekyll layout: post + cover: /assets/jekyll-gitbook/dinosaur.gif ---"
  },"/jekyll-gitbook/jekyll/2021-08-10-toc.html": {
    "title": "How to Generate TOC",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2021-08-10-toc.html",
    "body": "The jekyll-gitbook theme leverages jekyll-toc to generate the Contents for the page. The TOC feature is not enabled by default. To use the TOC feature, modify the TOC configuration in _config.yml: toc: enabled: true Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8"
  },"/jekyll-gitbook/jekyll/2019-04-29-license.html": {
    "title": "License",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-29-license.html",
    "body": "This work is open sourced under the Apache License, Version 2.0, using the same license as the original GitBook repository. Copyright 2019 Tao He."
  },"/jekyll-gitbook/jekyll/2019-04-28-howto.html": {
    "title": "How to Get Started",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-28-howto.html",
    "body": "The jekyll-gitbook theme can be used just as other Jekyll themes and support remote theme on Github Pages, see the official guide as well. You can introduce this jekyll theme into your own site by either Fork this repository and add your markdown posts to the _posts folder, then push to your own Github repository. Use as a remote theme in your _config.yml(just like what we do for this site itself), # Configurations title: Jekyll Gitbook longtitle: Jekyll Gitbook remote_theme: sighingnow/jekyll-gitbook TIP No need to push generated HTML bundle."
  },"/jekyll-gitbook/jekyll/2019-04-27-why.html": {
    "title": "Why Jekyll with GitBook",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-27-why.html",
    "body": "GitBook is an amazing frontend style to present and organize contents (such as book chapters and blogs) on Web. The typical to deploy GitBook at Github Pages is building HTML files locally and then push to Github repository, usually to the gh-pages branch. However, it’s quite annoying to repeat such workload and make it hard for people do version control via git for when there are generated HTML files to be staged in and out. This theme takes style definition out of generated GitBook site and provided the template for Jekyll to rendering markdown documents to HTML, thus the whole site can be deployed to Github Pages without generating and uploading HTML bundle every time when there are changes to the original repository."
  }}
